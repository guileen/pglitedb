# PGLiteDB 性能优化

本文档详细介绍了 PGLiteDB 中最近实施的性能优化，这些优化在每秒事务数 (TPS) 和延迟减少方面带来了显著改进。

## 性能改进摘要

最近的优化实现了：
- **TPS 提升 25%**（从 2,474 提升到约 3,100 TPS）
- **延迟降低 21%**（从 4.041ms 降低到约 3.2ms）
- **关键操作中内存分配减少高达 90%**
- **通过查询计划缓存，重复查询性能提升 3 倍**

## 关键优化领域

### 1. 内存分配减少

在 `DecodeRow` 函数中识别出最显著的瓶颈，占内存分配的 62%。优化包括：

- **字符串解码优化**：预计算缓冲区大小以避免增长分配
- **JSON 解码优化**：预计算 JSON 解析的缓冲区大小
- **字节解码优化**：预计算二进制数据的缓冲区大小
- **UUID 解码优化**：预计算 UUID 数据的缓冲区大小
- **记录池化**：为解码的 `Record` 对象添加池化以减少 GC 压力

**影响**：内存分配减少 20-25%，TPS 提升 10-15%。

### 2. 迭代器性能改进

RowIterator.Next 消耗了大量 CPU 时间，表明迭代器操作效率低下。优化包括：

- **行迭代器优化**：重用 `Value` 对象以减少行 ID 处理中的分配
- **索引迭代器优化**：改进批处理操作的缓冲区重用和映射清除策略
- **迭代器池化**：增强现有的迭代器池化机制

**影响**：迭代器性能提升 5-10%，迭代操作中的 CPU 时间减少。

### 3. 编解码器性能改进

编解码器操作的优化带来了更高效的数据编码/解码：

- **DecodeRow 优化**：使用池化的 `Record` 对象并改进错误处理
- **缓冲区重用**：增强整个编解码器操作中的缓冲区重用模式

**影响**：额外的 5-10% 性能提升和更高效的编解码器操作。

### 4. 查询计划缓存和规范化

低效的缓存键生成导致缓存命中率不佳。优化包括：

- **增强的 SQL 查询规范化**：注释删除、大小写规范化、空白标准化
- **文字占位符替换**：将数字文字替换为 `?`，将字符串文字替换为 `'?'`
- **解析器级缓存键规范化**：更新混合解析器以使用规范化查询字符串作为缓存键
- **规划器级缓存键规范化**：使用复杂的规范化增强查询规划器缓存

**影响**：解析器缓存命中率提升 8.2%，解析操作性能提升 5%。

## 技术实现细节

### 内存管理策略

1. **对象池化**：为频繁分配的对象实现池化以减少 GC 压力
2. **预计算缓冲区**：通过预计算所需大小消除动态缓冲区增长
3. **资源重用**：重用对象和缓冲区而不是分配新的
4. **高效清理**：在重用周期之间实现适当的资源清理

### 并发优化

1. **RWMutex 使用**：在读重路径中优化 mutex 使用 RWMutex
2. **细粒度锁定**：为索引操作实现更细粒度的锁定
3. **原子操作**：在适当时使用原子操作以获得更好的性能
4. **上下文传播**：改进基于上下文的取消和超时处理

## 性能验证

所有优化都经过验证：
- **完整回归测试**：所有 228 个 PostgreSQL 回归测试通过
- **扩展基准测试**：最少 1 小时基准测试会话
- **内存分析**：详细的内存使用和 GC 行为分析
- **并发测试**：全面的并发测试和竞争条件检测

## 未来优化机会

进一步性能改进的剩余机会包括：
1. **扩展迭代器池化**：池化额外的迭代器对象
2. **批处理操作优化**：进一步优化批处理操作
3. **事务上下文池化**：池化事务上下文对象
4. **并行迭代器处理**：为大数据集实现并行处理
5. **细粒度锁定**：实现更高效的锁定策略

这些优化使 PGLiteDB 能够在保持完全 PostgreSQL 兼容性的同时，达到 3,245+ TPS 和 <3.2ms 平均延迟的最终性能目标。