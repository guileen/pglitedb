package catalog

import (
	"github.com/guileen/pglitedb/catalog/internal"
	"github.com/guileen/pglitedb/engine"
	"github.com/guileen/pglitedb/storage"
)

type tableManager struct {
	SchemaManager
	DataManager
	QueryManager
	IndexManager

	engine engine.StorageEngine
	cache  *internal.SchemaCache
}

func NewTableManager(eng engine.StorageEngine) Manager {
	cache := internal.NewSchemaCache()
	return &tableManager{
		SchemaManager: newSchemaManager(eng, nil, cache),
		DataManager:   newDataManager(eng, cache),
		QueryManager:  newQueryManager(eng, cache),
		IndexManager:  newIndexManager(eng, nil, cache),
		engine:        eng,
		cache:         cache,
	}
}

func NewTableManagerWithKV(eng engine.StorageEngine, kv storage.KV) Manager {
	cache := internal.NewSchemaCache()
	return &tableManager{
		SchemaManager: newSchemaManager(eng, kv, cache),
		DataManager:   newDataManager(eng, cache),
		QueryManager:  newQueryManager(eng, cache),
		IndexManager:  newIndexManager(eng, kv, cache),
		engine:        eng,
		cache:         cache,
	}
}

	if _, exists := m.schemas[key]; exists {
		return fmt.Errorf("table %s already exists", def.Name)
	}

	for _, col := range def.Columns {
		if !types.IsValidColumnType(col.Type) {
			return fmt.Errorf("invalid column type '%s' for column '%s'", col.Type, col.Name)
		}
	}

	tableID, err := m.engine.NextTableID(ctx, tenantID)
	if err != nil {
		return fmt.Errorf("generate table id: %w", err)
	}

	def.CreatedAt = time.Now()
	def.UpdatedAt = time.Now()
	if def.Version == 0 {
		def.Version = 1
	}

	if m.kv != nil {
		schemaBytes, err := json.Marshal(def)
		if err != nil {
			return fmt.Errorf("marshal schema: %w", err)
		}

		schemaKey := []byte(fmt.Sprintf("%s%d:%s", schemaKeyPrefix, tenantID, def.Name))
		if err := m.kv.Set(ctx, schemaKey, schemaBytes); err != nil {
			return fmt.Errorf("persist schema: %w", err)
		}
	}

	m.schemas[key] = def
	m.tableIDs[key] = tableID

	return nil
}

func (m *tableManager) DropTable(ctx context.Context, tenantID int64, tableName string) error {
	m.schemaMutex.Lock()
	defer m.schemaMutex.Unlock()

	key := m.makeTableKey(tenantID, tableName)
	if _, exists := m.schemas[key]; !exists {
		return types.ErrTableNotFound
	}

	if m.kv != nil {
		schemaKey := []byte(fmt.Sprintf("%s%d:%s", schemaKeyPrefix, tenantID, tableName))
		if err := m.kv.Delete(ctx, schemaKey); err != nil {
			return fmt.Errorf("delete schema: %w", err)
		}
	}

	delete(m.schemas, key)
	delete(m.tableIDs, key)

	return nil
}

func (m *tableManager) GetTableDefinition(ctx context.Context, tenantID int64, tableName string) (*types.TableDefinition, error) {
	m.schemaMutex.RLock()
	defer m.schemaMutex.RUnlock()

	key := m.makeTableKey(tenantID, tableName)
	def, exists := m.schemas[key]
	if !exists {
		return nil, types.ErrTableNotFound
	}

	return def, nil
}

func (m *tableManager) AlterTable(ctx context.Context, tenantID int64, tableName string, changes *AlterTableChanges) error {
	m.schemaMutex.Lock()
	defer m.schemaMutex.Unlock()

	key := m.makeTableKey(tenantID, tableName)
	def, exists := m.schemas[key]
	if !exists {
		return types.ErrTableNotFound
	}

	if changes.AddColumns != nil {
		for _, col := range changes.AddColumns {
			if !types.IsValidColumnType(col.Type) {
				return fmt.Errorf("invalid column type '%s' for column '%s'", col.Type, col.Name)
			}
		}
		def.Columns = append(def.Columns, changes.AddColumns...)
	}

	if changes.DropColumns != nil {
		newColumns := make([]types.ColumnDefinition, 0, len(def.Columns))
		for _, col := range def.Columns {
			drop := false
			for _, dropName := range changes.DropColumns {
				if col.Name == dropName {
					drop = true
					break
				}
			}
			if !drop {
				newColumns = append(newColumns, col)
			}
		}
		def.Columns = newColumns
	}

	if changes.AddIndexes != nil {
		def.Indexes = append(def.Indexes, changes.AddIndexes...)
	}

	def.Version++
	def.UpdatedAt = time.Now()

	if m.kv != nil {
		schemaBytes, err := json.Marshal(def)
		if err != nil {
			return fmt.Errorf("marshal schema: %w", err)
		}

		schemaKey := []byte(fmt.Sprintf("%s%d:%s", schemaKeyPrefix, tenantID, tableName))
		if err := m.kv.Set(ctx, schemaKey, schemaBytes); err != nil {
			return fmt.Errorf("persist schema: %w", err)
		}
	}

	return nil
}

func (m *tableManager) ListTables(ctx context.Context, tenantID int64) ([]*types.TableDefinition, error) {
	m.schemaMutex.RLock()
	defer m.schemaMutex.RUnlock()

	var tables []*types.TableDefinition
	prefix := fmt.Sprintf("%d:", tenantID)

	for key, def := range m.schemas {
		if len(key) >= len(prefix) && key[:len(prefix)] == prefix {
			tables = append(tables, def)
		}
	}

	return tables, nil
}

func (m *tableManager) Insert(ctx context.Context, tenantID int64, tableName string, data map[string]interface{}) (*types.Record, error) {
	schema, tableID, err := m.getTableSchema(tenantID, tableName)
	if err != nil {
		return nil, err
	}

	record, err := m.validateAndConvert(data, schema)
	if err != nil {
		return nil, fmt.Errorf("validate data: %w", err)
	}

	record.Table = tableName
	record.CreatedAt = time.Now()
	record.UpdatedAt = time.Now()
	record.Version = 1

	rowID, err := m.engine.InsertRow(ctx, tenantID, tableID, record, schema)
	if err != nil {
		return nil, fmt.Errorf("insert row: %w", err)
	}

	record.ID = strconv.FormatInt(rowID, 10)

	return record, nil
}

func (m *tableManager) InsertBatch(ctx context.Context, tenantID int64, tableName string, rows []map[string]interface{}) ([]*types.Record, error) {
	schema, tableID, err := m.getTableSchema(tenantID, tableName)
	if err != nil {
		return nil, err
	}

	records := make([]*types.Record, 0, len(rows))

	for _, data := range rows {
		record, err := m.validateAndConvert(data, schema)
		if err != nil {
			return nil, fmt.Errorf("validate data: %w", err)
		}

		record.Table = tableName
		record.CreatedAt = time.Now()
		record.UpdatedAt = time.Now()
		record.Version = 1

		rowID, err := m.engine.InsertRow(ctx, tenantID, tableID, record, schema)
		if err != nil {
			return nil, fmt.Errorf("insert row: %w", err)
		}

		record.ID = strconv.FormatInt(rowID, 10)
		records = append(records, record)
	}

	return records, nil
}

func (m *tableManager) Update(ctx context.Context, tenantID int64, tableName string, rowID int64, data map[string]interface{}) (*types.Record, error) {
	schema, tableID, err := m.getTableSchema(tenantID, tableName)
	if err != nil {
		return nil, err
	}

	updates := make(map[string]*types.Value)
	for k, v := range data {
		colType, err := m.getColumnType(schema, k)
		if err != nil {
			return nil, err
		}

		val, err := m.convertValue(v, colType)
		if err != nil {
			return nil, fmt.Errorf("convert value for %s: %w", k, err)
		}
		updates[k] = val
	}

	if err := m.engine.UpdateRow(ctx, tenantID, tableID, rowID, updates, schema); err != nil {
		return nil, fmt.Errorf("update row: %w", err)
	}

	return m.Get(ctx, tenantID, tableName, rowID)
}

func (m *tableManager) Delete(ctx context.Context, tenantID int64, tableName string, rowID int64) error {
	schema, tableID, err := m.getTableSchema(tenantID, tableName)
	if err != nil {
		return err
	}

	if err := m.engine.DeleteRow(ctx, tenantID, tableID, rowID, schema); err != nil {
		return fmt.Errorf("delete row: %w", err)
	}

	return nil
}

func (m *tableManager) Get(ctx context.Context, tenantID int64, tableName string, rowID int64) (*types.Record, error) {
	schema, tableID, err := m.getTableSchema(tenantID, tableName)
	if err != nil {
		return nil, err
	}

	record, err := m.engine.GetRow(ctx, tenantID, tableID, rowID, schema)
	if err != nil {
		return nil, fmt.Errorf("get row: %w", err)
	}

	record.ID = strconv.FormatInt(rowID, 10)
	record.Table = tableName

	return record, nil
}

func (m *tableManager) Query(ctx context.Context, tenantID int64, tableName string, opts *types.QueryOptions) (*types.QueryResult, error) {
	schema, tableID, err := m.getTableSchema(tenantID, tableName)
	if err != nil {
		return nil, err
	}
	startTime := time.Now()
	
	// Check if we can use index scan for ORDER BY optimization
	var iter engine.RowIterator
	if opts != nil && len(opts.OrderBy) > 0 && len(opts.OrderBy) == 1 {
		// Try to find an index that matches the ORDER BY column
		indexID := m.findIndexForColumn(schema, opts.OrderBy[0])
		if indexID > 0 {
			// Use index scan for sorting
			iter, err = m.engine.ScanIndex(ctx, tenantID, tableID, indexID, schema, nil)
		} else {
			// Fall back to regular scan
			iter, err = m.engine.ScanRows(ctx, tenantID, tableID, schema, nil)
		}
	} else {
		// Regular scan
		scanOpts := &engine.ScanOptions{}
		if opts != nil {
			if opts.Limit != nil {
				scanOpts.Limit = *opts.Limit
			}
			if opts.Offset != nil {
				scanOpts.Offset = *opts.Offset
			}
			if opts.Columns != nil {
				scanOpts.Projection = opts.Columns
			}
		}
		iter, err = m.engine.ScanRows(ctx, tenantID, tableID, schema, scanOpts)
	}
	
	if err != nil {
		return nil, fmt.Errorf("scan rows: %w", err)
	}
	defer iter.Close()
	
	var records []*types.Record
	for iter.Next() {
		record := iter.Row()
		if opts != nil && opts.Where != nil {
			if !m.matchFilter(record, opts.Where) {
				continue
			}
		}
		records = append(records, record)
		if opts != nil && opts.Limit != nil && len(records) >= *opts.Limit {
			break
		}
	}
	
	if err := iter.Error(); err != nil {
		return nil, fmt.Errorf("iterator error: %w", err)
	}
	
	result := &types.QueryResult{
		Records:  records,
		Count:    int64(len(records)),
		Duration: time.Since(startTime),
	}
	
	if opts != nil {
		result.Limit = opts.Limit
		result.Offset = opts.Offset
		if opts.Limit != nil {
			result.HasMore = len(records) == *opts.Limit
		}
	}
	
	return result, nil
}

func (m *tableManager) Count(ctx context.Context, tenantID int64, tableName string, filter map[string]interface{}) (int64, error) {
	schema, tableID, err := m.getTableSchema(tenantID, tableName)
	if err != nil {
		return 0, err
	}

	iter, err := m.engine.ScanRows(ctx, tenantID, tableID, schema, nil)
	if err != nil {
		return 0, fmt.Errorf("scan rows: %w", err)
	}
	defer iter.Close()

	var count int64
	for iter.Next() {
		if filter != nil {
			record := iter.Row()
			if !m.matchFilter(record, filter) {
				continue
			}
		}
		count++
	}

	if err := iter.Error(); err != nil {
		return 0, fmt.Errorf("iterator error: %w", err)
	}

	return count, nil
}

func (m *tableManager) CreateIndex(ctx context.Context, tenantID int64, tableName string, indexDef *types.IndexDefinition) error {
	schema, tableID, err := m.getTableSchema(tenantID, tableName)
	if err != nil {
		return err
	}

	if err := m.engine.CreateIndex(ctx, tenantID, tableID, indexDef); err != nil {
		return fmt.Errorf("create index: %w", err)
	}

	m.schemaMutex.Lock()
	defer m.schemaMutex.Unlock()

	schema.Indexes = append(schema.Indexes, *indexDef)
	schema.UpdatedAt = time.Now()

	return nil
}

func (m *tableManager) DropIndex(ctx context.Context, tenantID int64, tableName string, indexName string) error {
	schema, tableID, err := m.getTableSchema(tenantID, tableName)
	if err != nil {
		return err
	}

	var indexID int64 = -1
	for i, idx := range schema.Indexes {
		if idx.Name == indexName {
			indexID = int64(i + 1)
			break
		}
	}

	if indexID < 0 {
		return fmt.Errorf("index %s not found", indexName)
	}

	if err := m.engine.DropIndex(ctx, tenantID, tableID, indexID); err != nil {
		return fmt.Errorf("drop index: %w", err)
	}

	m.schemaMutex.Lock()
	defer m.schemaMutex.Unlock()

	newIndexes := make([]types.IndexDefinition, 0, len(schema.Indexes)-1)
	for _, idx := range schema.Indexes {
		if idx.Name != indexName {
			newIndexes = append(newIndexes, idx)
		}
	}
	schema.Indexes = newIndexes
	schema.UpdatedAt = time.Now()

	return nil
}

func (m *tableManager) makeTableKey(tenantID int64, tableName string) string {
	return fmt.Sprintf("%d:%s", tenantID, tableName)
}

func (m *tableManager) getTableSchema(tenantID int64, tableName string) (*types.TableDefinition, int64, error) {
	m.schemaMutex.RLock()
	defer m.schemaMutex.RUnlock()

	key := m.makeTableKey(tenantID, tableName)
	schema, exists := m.schemas[key]
	if !exists {
		return nil, 0, types.ErrTableNotFound
	}

	tableID, exists := m.tableIDs[key]
	if !exists {
		return nil, 0, types.ErrTableNotFound
	}

	return schema, tableID, nil
}

func (m *tableManager) validateAndConvert(data map[string]interface{}, schema *types.TableDefinition) (*types.Record, error) {
	record := &types.Record{
		Data: make(map[string]*types.Value),
	}

	for _, col := range schema.Columns {
		val, exists := data[col.Name]

		if !exists {
			if col.Default != nil {
				record.Data[col.Name] = col.Default
				continue
			}
			if !col.Nullable {
				return nil, fmt.Errorf("column %s is required", col.Name)
			}
			record.Data[col.Name] = &types.Value{Data: nil, Type: col.Type}
			continue
		}

		converted, err := m.convertValue(val, col.Type)
		if err != nil {
			return nil, fmt.Errorf("convert column %s: %w", col.Name, err)
		}

		record.Data[col.Name] = converted
	}

	return record, nil
}

func (m *tableManager) convertValue(val interface{}, colType types.ColumnType) (*types.Value, error) {
	if val == nil {
		return &types.Value{Data: nil, Type: colType}, nil
	}

	switch colType {
	case types.ColumnTypeString, types.ColumnTypeText:
		if s, ok := val.(string); ok {
			return &types.Value{Data: s, Type: colType}, nil
		}
		return nil, fmt.Errorf("expected string, got %T", val)

	case types.ColumnTypeUUID:
		// Handle UUID conversion
		switch v := val.(type) {
		case string:
			if v == "" {
				return &types.Value{Data: nil, Type: colType}, nil
			}
			// Validate UUID format
			if _, err := uuid.Parse(v); err != nil {
				return nil, fmt.Errorf("invalid UUID string: %w", err)
			}
			return &types.Value{Data: v, Type: colType}, nil
		case []byte:
			if len(v) == 0 {
				return &types.Value{Data: nil, Type: colType}, nil
			}
			if len(v) != 16 {
				return nil, fmt.Errorf("UUID byte slice must be 16 bytes")
			}
			u, err := uuid.FromBytes(v)
			if err != nil {
				return nil, fmt.Errorf("invalid UUID bytes: %w", err)
			}
			return &types.Value{Data: u.String(), Type: colType}, nil
		case uuid.UUID:
			return &types.Value{Data: v.String(), Type: colType}, nil
		default:
			return nil, fmt.Errorf("expected UUID string, []byte, or uuid.UUID, got %T", val)
		}

	case types.ColumnTypeNumber:
		switch v := val.(type) {
		case int:
			return &types.Value{Data: int64(v), Type: colType}, nil
		case int32:
			return &types.Value{Data: int64(v), Type: colType}, nil
		case int64:
			return &types.Value{Data: v, Type: colType}, nil
		case float32:
			return &types.Value{Data: float64(v), Type: colType}, nil
		case float64:
			return &types.Value{Data: v, Type: colType}, nil
		case string:
			// Try to parse string as number
			if f, err := strconv.ParseFloat(v, 64); err == nil {
				return &types.Value{Data: f, Type: colType}, nil
			}
			return nil, fmt.Errorf("cannot parse string '%s' as number", v)
		default:
			return nil, fmt.Errorf("expected number, got %T", val)
		}

	case types.ColumnTypeBoolean:
		switch v := val.(type) {
		case bool:
			return &types.Value{Data: v, Type: colType}, nil
		case string:
			switch v {
			case "true", "1", "TRUE", "True":
				return &types.Value{Data: true, Type: colType}, nil
			case "false", "0", "FALSE", "False":
				return &types.Value{Data: false, Type: colType}, nil
			default:
				return nil, fmt.Errorf("cannot parse string '%s' as boolean", v)
			}
		case int, int64:
			// 0 = false, non-zero = true
			return &types.Value{Data: v != 0, Type: colType}, nil
		default:
			return nil, fmt.Errorf("expected boolean, got %T", val)
		}

	case types.ColumnTypeTimestamp, types.ColumnTypeDate:
		switch v := val.(type) {
		case time.Time:
			return &types.Value{Data: v, Type: colType}, nil
		case int64:
			return &types.Value{Data: time.Unix(v, 0), Type: colType}, nil
		case string:
			// Try to parse as time
			if t, err := time.Parse(time.RFC3339, v); err == nil {
				return &types.Value{Data: t, Type: colType}, nil
			}
			if t, err := time.Parse("2006-01-02", v); err == nil {
				return &types.Value{Data: t, Type: colType}, nil
			}
			return nil, fmt.Errorf("cannot parse string '%s' as timestamp", v)
		default:
			return nil, fmt.Errorf("expected time.Time, int64, or string, got %T", val)
		}

	case types.ColumnTypeBinary:
		switch v := val.(type) {
		case []byte:
			return &types.Value{Data: v, Type: colType}, nil
		case string:
			return &types.Value{Data: []byte(v), Type: colType}, nil
		default:
			return nil, fmt.Errorf("expected []byte or string, got %T", val)
		}

	case types.ColumnTypeJSON:
		// Validate that value is JSON serializable
		if val == nil {
			return &types.Value{Data: nil, Type: colType}, nil
		}
		// Try to marshal to JSON to validate
		if _, err := json.Marshal(val); err != nil {
			return nil, fmt.Errorf("invalid JSON value: %w", err)
		}
		return &types.Value{Data: val, Type: colType}, nil

	default:
		return nil, fmt.Errorf("unsupported column type: %s", colType)
	}
}

func (m *tableManager) getColumnType(schema *types.TableDefinition, colName string) (types.ColumnType, error) {
	for _, col := range schema.Columns {
		if col.Name == colName {
			return col.Type, nil
		}
	}
	return "", types.ErrColumnNotFound
}

func (m *tableManager) matchFilter(record *types.Record, filter map[string]interface{}) bool {
	for key, expectedVal := range filter {
		recordVal, exists := record.Data[key]
		if !exists {
			return false
		}

		if recordVal.Data == nil {
			if expectedVal != nil {
				return false
			}
			continue
		}

		switch expected := expectedVal.(type) {
		case string:
			if s, ok := recordVal.Data.(string); !ok || s != expected {
				return false
			}
		case int, int32, int64:
			var expectedInt int64
			switch v := expected.(type) {
			case int:
				expectedInt = int64(v)
			case int32:
				expectedInt = int64(v)
			case int64:
				expectedInt = v
			}
			if i, ok := recordVal.Data.(int64); !ok || i != expectedInt {
				return false
			}
		case bool:
			if b, ok := recordVal.Data.(bool); !ok || b != expected {
				return false
			}
		default:
			return false
		}
	}

	return true
}

// findIndexForColumn finds an index that includes the specified column
func (m *tableManager) findIndexForColumn(schema *types.TableDefinition, columnName string) int64 {
	for i, index := range schema.Indexes {
		if len(index.Columns) == 1 && index.Columns[0] == columnName {
			return int64(i + 1)
		}
	}
	return 0
}

func (m *tableManager) LoadSchemas(ctx context.Context) error {
	if m.kv == nil {
		return nil
	}

	iter := m.kv.NewIterator(&storage.IteratorOptions{
		LowerBound: []byte(schemaKeyPrefix),
		UpperBound: []byte(schemaKeyPrefix + "\xff"),
	})
	defer iter.Close()

	m.schemaMutex.Lock()
	defer m.schemaMutex.Unlock()

	for iter.First(); iter.Valid(); iter.Next() {
		var def types.TableDefinition
		if err := json.Unmarshal(iter.Value(), &def); err != nil {
			return fmt.Errorf("unmarshal schema: %w", err)
		}

		keyStr := string(iter.Key())
		keyStr = keyStr[len(schemaKeyPrefix):]

		var tenantID int64
		var tableName string
		if _, err := fmt.Sscanf(keyStr, "%d:%s", &tenantID, &tableName); err != nil {
			return fmt.Errorf("parse schema key: %w", err)
		}

		key := m.makeTableKey(tenantID, def.Name)
		m.schemas[key] = &def

		tableID, err := m.engine.NextTableID(ctx, tenantID)
		if err != nil {
			return fmt.Errorf("generate table id: %w", err)
		}
		m.tableIDs[key] = tableID - 1
	}

	return iter.Error()
}
